<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>feature API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>feature</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from __future__ import annotations
from dataclasses import dataclass

from typing import List, Optional, Literal


from datatype import DataType
from datetime import timedelta

from common import Metadata
from code import DataCode
from datacheck import DataChecksForFeature


@dataclass
class Feature:
    &#34;&#34;&#34;An individual feature.

    Visual depiction: https://ibb.co/9t2zhXS

    Features form the basis of machine learning and are the core unit of abstraction in Orchestra&#39;s data model.

    Author&#39;s note (EP):
    I&#39;ve heard different perspectives on what a &#34;feature&#34; is, particularly when speaking to practitioners who exclusively work with modern NLP or computer vision techniques and only have model inputs that are embeddings (floating point vectors) created directly from the raw data without any business logic (e.g., text ‚Äî&gt; embedding or image ‚Äî&gt; embedding).  In this situation, I often hear &#34;we don&#39;t have features, we just use embeddings as model input‚Äù although I have also heard &#34;we do a bit of text clean up before applying an embedding based model in order to reduce our cost profile so it is a feature.&#34;

    I believe there is great benefit to creating a common definition of a Feature that includes both modern techniques (ala transformers, etc) and traditionally engineered features (ala feature engineering) as I expect for the foreseeable future (note 1) a single company&#39;s full breadth of models will include both.  This common definition will also ease communication with business stakeholders about how machine learning works.
    &#34;&#34;&#34;

    def __init__():
        super().__init__()
        return

    metadata: Metadata
    &#34;&#34;&#34;
    name, description, key:value tags
    &#34;&#34;&#34;

    input_features: List[Feature]
    &#34;&#34;&#34;
    The input data used to create this feature.

    If Features from 2+ different `Datasets` are used, both `Datasets` must share the same `Key` space.
    &#34;&#34;&#34;

    input_lookups: Optional[List[Feature]]
    &#34;&#34;&#34;
    Optional, used for join-like logic or where a value must be looked up from another table that doesn&#39;t share the primary key space. 
    
    The `Key(s)` of each `input_lookups[Feature]`&#39;s `Dataset` must be included as `input_features`
    &#34;&#34;&#34;

    human_datatype: DataType
    &#34;&#34;&#34;
    The human-readable data type that is output by the code specified by `business_logic`
    &#34;&#34;&#34;

    model_datatypes: List[DataType]
    &#34;&#34;&#34;
    Output only.  Set automatically based on the `ml_transformations.output_datatype`&#39;s&#34;&#34;&#34;

    business_logics: Optional[List[DataCode]]
    &#34;&#34;&#34;
    Optional. Business logic that translates the input_features into this feature.  Each provided DataCode is executed in order, passing information between steps.

    Can be 1+ DataCodes. 

    A transformation created based on a business understanding of the data in order to provide additional context to the model in order to accelerate or simplify how it learns patterns in the data.  Examples include calculating a total purchase amount that includes tax, collapsing categories that are actually the same, etc.  Business logic is optional (for example, if the feature is ‚Äúchat message‚Äù there is no need for additional business logic).  

    A common piece of business logic to apply is an aggregation over multiple rows of data, or combining values over a specific time period through an average, count, sum, etc (in SQL, this is referred to as a GROUP BY).  This pattern creates complexity for productionizing features since at model inference time, typically only the current row of data is available.  Orchestra&#39;s Aggregation abstraction simplifies the process of writing production-ready aggregations [see action items below for a discussion].

    Author&#39;s note (EP): In my conversations with 100s of ML practitioners, I have heard inconsistency in what each of these 2 steps (business logic, ML-specific transformations) are called.  Some say ‚Äúfeature engineering‚Äù, some say ‚Äúpre-processing‚Äù, some use a combination of both terms.  Potato-patato.  Irregardless of what you call it, folks apply business logic, then transform everything to numbers.
   
    &#34;&#34;&#34;

    ml_transformations: Optional[List[MLTransformation]]
    &#34;&#34;&#34;
    Optional ML transformations (aka pre-processing aka functions that translate from human-readable data to model-readable data).
    
    If not provided, Orchestra will check that only model-readable DataTypes pass through.

    ML-specific transformations: a transformation that is done only for the purposes of translating the data into a format a model can understand.  Said differently, these transformations would never happen outside the context of machine learning (e.g., would not be done inside a traditional BI table) and do NOT change what the data describes, only how the data is represented (e.g., a ML transformation will not go from ‚Äúmeaning A‚Äù to ‚Äúmeaning B‚Äù).

    Author&#39;s note (EP): In my conversations with 100s of ML practitioners, I have heard inconsistency in what each of these 2 steps (business logic, ML-specific transformations) are called.  Some say ‚Äúfeature engineering‚Äù, some say ‚Äúpre-processing‚Äù, some use a combination of both terms.  Potato-patato.  Irregardless of what you call it, folks apply business logic, then transform everything to numbers.

    &#34;&#34;&#34;

    freshness: timedelta
    &#34;&#34;&#34;
    How frequently does this feature&#39;s value need to be updated to reflect the most recently available upstream/source data?

    Implemented as: If [now() - time_of_last_computation] &gt;= `freshness`, recompute the value if any of input_features have changed within the time window [now() --&gt; time_of_last_computation]
    
    &#34;&#34;&#34;

    data_checks: Optional[DataChecksForFeature]
    &#34;&#34;&#34;
    Any data quality or data distribution checks that should be performed.  Executed by Orchesrta using the user&#39;s supplied checking framwork.
    &#34;&#34;&#34;


class RawFeature(Feature):
    &#34;&#34;&#34;
    Data that comes directly from a DataProvider and will never be manipulated directly by Orchestra.  If a value here is ‚Äúbad‚Äù - it is 100% the fault of the DataProvider&#39;s owner üòâ
    &#34;&#34;&#34;

    ml_transformations: None
    business_logic: None
    input_features: None

    freshness: timedelta
    &#34;&#34;&#34;
    Output only.
    Automatically generated by Orchestra based on the DatasetProvider attached to the Dataset
    &#34;&#34;&#34;


class DerivedFeature(Feature):
    &#34;&#34;&#34;
    Data that is manipulated by Orchestra based on the user&#39;s declarations.  This is the most commonly used class within Orchestra.
    &#34;&#34;&#34;


class Key(Feature):
    &#34;&#34;&#34;A primary or secondary key field.  Used for aggregations and lookups.&#34;&#34;&#34;

    ml_transformations: None
    business_logic: None
    input_features: None
    freshness: None
    model_datatypes: None


class Timestamp(Feature):
    &#34;&#34;&#34;
    A data value that represents the timestamp of when other Features in that row of data were created or updated.  Used for time-travel and time-aware joins.
    &#34;&#34;&#34;

    timestamp_format: str
    &#34;&#34;&#34;
    Format of the timestamp e.g., seconds since epoch, YYYYmmddHHss, etc
    &#34;&#34;&#34;

    # TODO: Should timestamp be a special sub-class or not? I think yes but 85% sure.

    ml_transformations: None
    business_logic: None
    input_features: None
    freshness: None
    data_checks: None


class Aggregation(DataCode):
    &#34;&#34;&#34;
    Defines an aggregation function.

    aka GROUP BY in SQL

    &#34;&#34;&#34;

    records_needed: Literal[&#34;Aggregation&#34;]
    &#34;&#34;&#34;
    Default value, can&#39;t be changed
    &#34;&#34;&#34;

    aggregate_function: Literal[&#34;SUM&#34;, &#34;COUNT&#34;, &#34;MAX&#34;, &#34;MIN&#34;, &#34;AVG&#34;, &#34;CUSTOM&#34;]
    &#34;&#34;&#34;
    What function is used to compute the aggregation?

    All except CUSTOM are built-in to Orchestra.

    SELECT aggregate_function(Feature) FROM ...

    Credit: Portions borrowed from the Feathr spec 
    &#34;&#34;&#34;

    aggregate_by: List[Feature]
    &#34;&#34;&#34;
    What Features are we aggregating by?

    ... GROUP BY [aggregate_by, ...]
    &#34;&#34;&#34;

    custom_function: Optional[DataCode]
    &#34;&#34;&#34;
        TODO: define the limits of what types of DataCode can be provided here
    &#34;&#34;&#34;

    window: str
    &#34;&#34;&#34;
    Either a time window or the last N records.

    d(day)
    h(hour)
    m(minute)
    s(second)
    n(last n records)
    
    Examples: ‚Äú7d‚Äô or ‚Äú5h‚Äù or ‚Äú3m‚Äù or ‚Äú1s‚Äù or &#34;5n&#34;

    Any time window: ... WHERE now() - record_timestamp &lt;= window
    Any N window: ... ORDER BY [order_by, ...] LIMIT n

    Credit: Portions borrowed from the Feathr spec 
    &#34;&#34;&#34;

    order_by: Optional[tuple(List[Feature], Literal[&#34;DESC&#34;, &#34;ASC&#34;])]
    &#34;&#34;&#34;
    Features to sort the records by

    Only applies if window is a last N records.
    &#34;&#34;&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="feature.Aggregation"><code class="flex name class">
<span>class <span class="ident">Aggregation</span></span>
</code></dt>
<dd>
<div class="desc"><p>Defines an aggregation function.</p>
<p>aka GROUP BY in SQL</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Aggregation(DataCode):
    &#34;&#34;&#34;
    Defines an aggregation function.

    aka GROUP BY in SQL

    &#34;&#34;&#34;

    records_needed: Literal[&#34;Aggregation&#34;]
    &#34;&#34;&#34;
    Default value, can&#39;t be changed
    &#34;&#34;&#34;

    aggregate_function: Literal[&#34;SUM&#34;, &#34;COUNT&#34;, &#34;MAX&#34;, &#34;MIN&#34;, &#34;AVG&#34;, &#34;CUSTOM&#34;]
    &#34;&#34;&#34;
    What function is used to compute the aggregation?

    All except CUSTOM are built-in to Orchestra.

    SELECT aggregate_function(Feature) FROM ...

    Credit: Portions borrowed from the Feathr spec 
    &#34;&#34;&#34;

    aggregate_by: List[Feature]
    &#34;&#34;&#34;
    What Features are we aggregating by?

    ... GROUP BY [aggregate_by, ...]
    &#34;&#34;&#34;

    custom_function: Optional[DataCode]
    &#34;&#34;&#34;
        TODO: define the limits of what types of DataCode can be provided here
    &#34;&#34;&#34;

    window: str
    &#34;&#34;&#34;
    Either a time window or the last N records.

    d(day)
    h(hour)
    m(minute)
    s(second)
    n(last n records)
    
    Examples: ‚Äú7d‚Äô or ‚Äú5h‚Äù or ‚Äú3m‚Äù or ‚Äú1s‚Äù or &#34;5n&#34;

    Any time window: ... WHERE now() - record_timestamp &lt;= window
    Any N window: ... ORDER BY [order_by, ...] LIMIT n

    Credit: Portions borrowed from the Feathr spec 
    &#34;&#34;&#34;

    order_by: Optional[tuple(List[Feature], Literal[&#34;DESC&#34;, &#34;ASC&#34;])]
    &#34;&#34;&#34;
    Features to sort the records by

    Only applies if window is a last N records.
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="code.DataCode" href="code.html#code.DataCode">DataCode</a></li>
<li><a title="code.Code" href="code.html#code.Code">Code</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="feature.Aggregation.aggregate_by"><code class="name">var <span class="ident">aggregate_by</span> :¬†List[<a title="feature.Feature" href="#feature.Feature">Feature</a>]</code></dt>
<dd>
<div class="desc"><p>What Features are we aggregating by?</p>
<p>&hellip; GROUP BY [aggregate_by, &hellip;]</p></div>
</dd>
<dt id="feature.Aggregation.aggregate_function"><code class="name">var <span class="ident">aggregate_function</span> :¬†Literal['SUM',¬†'COUNT',¬†'MAX',¬†'MIN',¬†'AVG',¬†'CUSTOM']</code></dt>
<dd>
<div class="desc"><p>What function is used to compute the aggregation?</p>
<p>All except CUSTOM are built-in to Orchestra.</p>
<p>SELECT aggregate_function(Feature) FROM &hellip;</p>
<p>Credit: Portions borrowed from the Feathr spec</p></div>
</dd>
<dt id="feature.Aggregation.custom_function"><code class="name">var <span class="ident">custom_function</span> :¬†Optional[DataCode]</code></dt>
<dd>
<div class="desc"><p>TODO: define the limits of what types of DataCode can be provided here</p></div>
</dd>
<dt id="feature.Aggregation.order_by"><code class="name">var <span class="ident">order_by</span> :¬†Optional[tuple(List[<a title="feature.Feature" href="#feature.Feature">Feature</a>],¬†Literal['DESC',¬†'ASC'])]</code></dt>
<dd>
<div class="desc"><p>Features to sort the records by</p>
<p>Only applies if window is a last N records.</p></div>
</dd>
<dt id="feature.Aggregation.records_needed"><code class="name">var <span class="ident">records_needed</span> :¬†Literal['<a title="feature.Aggregation" href="#feature.Aggregation">Aggregation</a>']</code></dt>
<dd>
<div class="desc"><p>Default value, can't be changed</p></div>
</dd>
<dt id="feature.Aggregation.window"><code class="name">var <span class="ident">window</span> :¬†str</code></dt>
<dd>
<div class="desc"><p>Either a time window or the last N records.</p>
<p>d(day)
h(hour)
m(minute)
s(second)
n(last n records)</p>
<p>Examples: ‚Äú7d‚Äô or ‚Äú5h‚Äù or ‚Äú3m‚Äù or ‚Äú1s‚Äù or "5n"</p>
<p>Any time window: &hellip; WHERE now() - record_timestamp &lt;= window
Any N window: &hellip; ORDER BY [order_by, &hellip;] LIMIT n</p>
<p>Credit: Portions borrowed from the Feathr spec</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="code.DataCode" href="code.html#code.DataCode">DataCode</a></b></code>:
<ul class="hlist">
<li><code><a title="code.DataCode.input_records_needed" href="code.html#code.DataCode.input_records_needed">input_records_needed</a></code></li>
</ul>
</li>
<li><code><b><a title="code.Code" href="code.html#code.Code">Code</a></b></code>:
<ul class="hlist">
<li><code><a title="code.Code.location" href="code.html#code.Code.location">location</a></code></li>
<li><code><a title="code.Code.metadata" href="code.html#code.Code.metadata">metadata</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="feature.DerivedFeature"><code class="flex name class">
<span>class <span class="ident">DerivedFeature</span></span>
</code></dt>
<dd>
<div class="desc"><p>Data that is manipulated by Orchestra based on the user's declarations.
This is the most commonly used class within Orchestra.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DerivedFeature(Feature):
    &#34;&#34;&#34;
    Data that is manipulated by Orchestra based on the user&#39;s declarations.  This is the most commonly used class within Orchestra.
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="feature.Feature" href="#feature.Feature">Feature</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="feature.Feature" href="#feature.Feature">Feature</a></b></code>:
<ul class="hlist">
<li><code><a title="feature.Feature.business_logics" href="#feature.Feature.business_logics">business_logics</a></code></li>
<li><code><a title="feature.Feature.data_checks" href="#feature.Feature.data_checks">data_checks</a></code></li>
<li><code><a title="feature.Feature.freshness" href="#feature.Feature.freshness">freshness</a></code></li>
<li><code><a title="feature.Feature.human_datatype" href="#feature.Feature.human_datatype">human_datatype</a></code></li>
<li><code><a title="feature.Feature.input_features" href="#feature.Feature.input_features">input_features</a></code></li>
<li><code><a title="feature.Feature.input_lookups" href="#feature.Feature.input_lookups">input_lookups</a></code></li>
<li><code><a title="feature.Feature.metadata" href="#feature.Feature.metadata">metadata</a></code></li>
<li><code><a title="feature.Feature.ml_transformations" href="#feature.Feature.ml_transformations">ml_transformations</a></code></li>
<li><code><a title="feature.Feature.model_datatypes" href="#feature.Feature.model_datatypes">model_datatypes</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="feature.Feature"><code class="flex name class">
<span>class <span class="ident">Feature</span></span>
</code></dt>
<dd>
<div class="desc"><p>An individual feature.</p>
<p>Visual depiction: <a href="https://ibb.co/9t2zhXS">https://ibb.co/9t2zhXS</a></p>
<p>Features form the basis of machine learning and are the core unit of abstraction in Orchestra's data model.</p>
<p>Author's note (EP):
I've heard different perspectives on what a "feature" is, particularly when speaking to practitioners who exclusively work with modern NLP or computer vision techniques and only have model inputs that are embeddings (floating point vectors) created directly from the raw data without any business logic (e.g., text ‚Äî&gt; embedding or image ‚Äî&gt; embedding).
In this situation, I often hear "we don't have features, we just use embeddings as model input‚Äù although I have also heard "we do a bit of text clean up before applying an embedding based model in order to reduce our cost profile so it is a feature."</p>
<p>I believe there is great benefit to creating a common definition of a Feature that includes both modern techniques (ala transformers, etc) and traditionally engineered features (ala feature engineering) as I expect for the foreseeable future (note 1) a single company's full breadth of models will include both.
This common definition will also ease communication with business stakeholders about how machine learning works.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Feature:
    &#34;&#34;&#34;An individual feature.

    Visual depiction: https://ibb.co/9t2zhXS

    Features form the basis of machine learning and are the core unit of abstraction in Orchestra&#39;s data model.

    Author&#39;s note (EP):
    I&#39;ve heard different perspectives on what a &#34;feature&#34; is, particularly when speaking to practitioners who exclusively work with modern NLP or computer vision techniques and only have model inputs that are embeddings (floating point vectors) created directly from the raw data without any business logic (e.g., text ‚Äî&gt; embedding or image ‚Äî&gt; embedding).  In this situation, I often hear &#34;we don&#39;t have features, we just use embeddings as model input‚Äù although I have also heard &#34;we do a bit of text clean up before applying an embedding based model in order to reduce our cost profile so it is a feature.&#34;

    I believe there is great benefit to creating a common definition of a Feature that includes both modern techniques (ala transformers, etc) and traditionally engineered features (ala feature engineering) as I expect for the foreseeable future (note 1) a single company&#39;s full breadth of models will include both.  This common definition will also ease communication with business stakeholders about how machine learning works.
    &#34;&#34;&#34;

    def __init__():
        super().__init__()
        return

    metadata: Metadata
    &#34;&#34;&#34;
    name, description, key:value tags
    &#34;&#34;&#34;

    input_features: List[Feature]
    &#34;&#34;&#34;
    The input data used to create this feature.

    If Features from 2+ different `Datasets` are used, both `Datasets` must share the same `Key` space.
    &#34;&#34;&#34;

    input_lookups: Optional[List[Feature]]
    &#34;&#34;&#34;
    Optional, used for join-like logic or where a value must be looked up from another table that doesn&#39;t share the primary key space. 
    
    The `Key(s)` of each `input_lookups[Feature]`&#39;s `Dataset` must be included as `input_features`
    &#34;&#34;&#34;

    human_datatype: DataType
    &#34;&#34;&#34;
    The human-readable data type that is output by the code specified by `business_logic`
    &#34;&#34;&#34;

    model_datatypes: List[DataType]
    &#34;&#34;&#34;
    Output only.  Set automatically based on the `ml_transformations.output_datatype`&#39;s&#34;&#34;&#34;

    business_logics: Optional[List[DataCode]]
    &#34;&#34;&#34;
    Optional. Business logic that translates the input_features into this feature.  Each provided DataCode is executed in order, passing information between steps.

    Can be 1+ DataCodes. 

    A transformation created based on a business understanding of the data in order to provide additional context to the model in order to accelerate or simplify how it learns patterns in the data.  Examples include calculating a total purchase amount that includes tax, collapsing categories that are actually the same, etc.  Business logic is optional (for example, if the feature is ‚Äúchat message‚Äù there is no need for additional business logic).  

    A common piece of business logic to apply is an aggregation over multiple rows of data, or combining values over a specific time period through an average, count, sum, etc (in SQL, this is referred to as a GROUP BY).  This pattern creates complexity for productionizing features since at model inference time, typically only the current row of data is available.  Orchestra&#39;s Aggregation abstraction simplifies the process of writing production-ready aggregations [see action items below for a discussion].

    Author&#39;s note (EP): In my conversations with 100s of ML practitioners, I have heard inconsistency in what each of these 2 steps (business logic, ML-specific transformations) are called.  Some say ‚Äúfeature engineering‚Äù, some say ‚Äúpre-processing‚Äù, some use a combination of both terms.  Potato-patato.  Irregardless of what you call it, folks apply business logic, then transform everything to numbers.
   
    &#34;&#34;&#34;

    ml_transformations: Optional[List[MLTransformation]]
    &#34;&#34;&#34;
    Optional ML transformations (aka pre-processing aka functions that translate from human-readable data to model-readable data).
    
    If not provided, Orchestra will check that only model-readable DataTypes pass through.

    ML-specific transformations: a transformation that is done only for the purposes of translating the data into a format a model can understand.  Said differently, these transformations would never happen outside the context of machine learning (e.g., would not be done inside a traditional BI table) and do NOT change what the data describes, only how the data is represented (e.g., a ML transformation will not go from ‚Äúmeaning A‚Äù to ‚Äúmeaning B‚Äù).

    Author&#39;s note (EP): In my conversations with 100s of ML practitioners, I have heard inconsistency in what each of these 2 steps (business logic, ML-specific transformations) are called.  Some say ‚Äúfeature engineering‚Äù, some say ‚Äúpre-processing‚Äù, some use a combination of both terms.  Potato-patato.  Irregardless of what you call it, folks apply business logic, then transform everything to numbers.

    &#34;&#34;&#34;

    freshness: timedelta
    &#34;&#34;&#34;
    How frequently does this feature&#39;s value need to be updated to reflect the most recently available upstream/source data?

    Implemented as: If [now() - time_of_last_computation] &gt;= `freshness`, recompute the value if any of input_features have changed within the time window [now() --&gt; time_of_last_computation]
    
    &#34;&#34;&#34;

    data_checks: Optional[DataChecksForFeature]
    &#34;&#34;&#34;
    Any data quality or data distribution checks that should be performed.  Executed by Orchesrta using the user&#39;s supplied checking framwork.
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="feature.DerivedFeature" href="#feature.DerivedFeature">DerivedFeature</a></li>
<li><a title="feature.Key" href="#feature.Key">Key</a></li>
<li><a title="feature.RawFeature" href="#feature.RawFeature">RawFeature</a></li>
<li><a title="feature.Timestamp" href="#feature.Timestamp">Timestamp</a></li>
<li><a title="model.Label" href="model.html#model.Label">Label</a></li>
<li><a title="model.Prediction" href="model.html#model.Prediction">Prediction</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="feature.Feature.business_logics"><code class="name">var <span class="ident">business_logics</span> :¬†Optional[List[DataCode]]</code></dt>
<dd>
<div class="desc"><p>Optional. Business logic that translates the input_features into this feature.
Each provided DataCode is executed in order, passing information between steps.</p>
<p>Can be 1+ DataCodes. </p>
<p>A transformation created based on a business understanding of the data in order to provide additional context to the model in order to accelerate or simplify how it learns patterns in the data.
Examples include calculating a total purchase amount that includes tax, collapsing categories that are actually the same, etc.
Business logic is optional (for example, if the feature is ‚Äúchat message‚Äù there is no need for additional business logic).
</p>
<p>A common piece of business logic to apply is an aggregation over multiple rows of data, or combining values over a specific time period through an average, count, sum, etc (in SQL, this is referred to as a GROUP BY).
This pattern creates complexity for productionizing features since at model inference time, typically only the current row of data is available.
Orchestra's Aggregation abstraction simplifies the process of writing production-ready aggregations [see action items below for a discussion].</p>
<p>Author's note (EP): In my conversations with 100s of ML practitioners, I have heard inconsistency in what each of these 2 steps (business logic, ML-specific transformations) are called.
Some say ‚Äúfeature engineering‚Äù, some say ‚Äúpre-processing‚Äù, some use a combination of both terms.
Potato-patato.
Irregardless of what you call it, folks apply business logic, then transform everything to numbers.</p></div>
</dd>
<dt id="feature.Feature.data_checks"><code class="name">var <span class="ident">data_checks</span> :¬†Optional[DataChecksForFeature]</code></dt>
<dd>
<div class="desc"><p>Any data quality or data distribution checks that should be performed.
Executed by Orchesrta using the user's supplied checking framwork.</p></div>
</dd>
<dt id="feature.Feature.freshness"><code class="name">var <span class="ident">freshness</span> :¬†timedelta</code></dt>
<dd>
<div class="desc"><p>How frequently does this feature's value need to be updated to reflect the most recently available upstream/source data?</p>
<p>Implemented as: If [now() - time_of_last_computation] &gt;= <code>freshness</code>, recompute the value if any of input_features have changed within the time window [now() &ndash;&gt; time_of_last_computation]</p></div>
</dd>
<dt id="feature.Feature.human_datatype"><code class="name">var <span class="ident">human_datatype</span> :¬†DataType</code></dt>
<dd>
<div class="desc"><p>The human-readable data type that is output by the code specified by <code>business_logic</code></p></div>
</dd>
<dt id="feature.Feature.input_features"><code class="name">var <span class="ident">input_features</span> :¬†List[<a title="feature.Feature" href="#feature.Feature">Feature</a>]</code></dt>
<dd>
<div class="desc"><p>The input data used to create this feature.</p>
<p>If Features from 2+ different <code>Datasets</code> are used, both <code>Datasets</code> must share the same <code><a title="feature.Key" href="#feature.Key">Key</a></code> space.</p></div>
</dd>
<dt id="feature.Feature.input_lookups"><code class="name">var <span class="ident">input_lookups</span> :¬†Optional[List[<a title="feature.Feature" href="#feature.Feature">Feature</a>]]</code></dt>
<dd>
<div class="desc"><p>Optional, used for join-like logic or where a value must be looked up from another table that doesn't share the primary key space. </p>
<p>The <code><a title="feature.Key" href="#feature.Key">Key</a>(s)</code> of each <code>input_lookups[<a title="feature.Feature" href="#feature.Feature">Feature</a>]</code>'s <code>Dataset</code> must be included as <code>input_features</code></p></div>
</dd>
<dt id="feature.Feature.metadata"><code class="name">var <span class="ident">metadata</span> :¬†Metadata</code></dt>
<dd>
<div class="desc"><p>name, description, key:value tags</p></div>
</dd>
<dt id="feature.Feature.ml_transformations"><code class="name">var <span class="ident">ml_transformations</span> :¬†Optional[List[MLTransformation]]</code></dt>
<dd>
<div class="desc"><p>Optional ML transformations (aka pre-processing aka functions that translate from human-readable data to model-readable data).</p>
<p>If not provided, Orchestra will check that only model-readable DataTypes pass through.</p>
<p>ML-specific transformations: a transformation that is done only for the purposes of translating the data into a format a model can understand.
Said differently, these transformations would never happen outside the context of machine learning (e.g., would not be done inside a traditional BI table) and do NOT change what the data describes, only how the data is represented (e.g., a ML transformation will not go from ‚Äúmeaning A‚Äù to ‚Äúmeaning B‚Äù).</p>
<p>Author's note (EP): In my conversations with 100s of ML practitioners, I have heard inconsistency in what each of these 2 steps (business logic, ML-specific transformations) are called.
Some say ‚Äúfeature engineering‚Äù, some say ‚Äúpre-processing‚Äù, some use a combination of both terms.
Potato-patato.
Irregardless of what you call it, folks apply business logic, then transform everything to numbers.</p></div>
</dd>
<dt id="feature.Feature.model_datatypes"><code class="name">var <span class="ident">model_datatypes</span> :¬†List[DataType]</code></dt>
<dd>
<div class="desc"><p>Output only.
Set automatically based on the <code>ml_transformations.output_datatype</code>'s</p></div>
</dd>
</dl>
</dd>
<dt id="feature.Key"><code class="flex name class">
<span>class <span class="ident">Key</span></span>
</code></dt>
<dd>
<div class="desc"><p>A primary or secondary key field.
Used for aggregations and lookups.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Key(Feature):
    &#34;&#34;&#34;A primary or secondary key field.  Used for aggregations and lookups.&#34;&#34;&#34;

    ml_transformations: None
    business_logic: None
    input_features: None
    freshness: None
    model_datatypes: None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="feature.Feature" href="#feature.Feature">Feature</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="feature.Key.business_logic"><code class="name">var <span class="ident">business_logic</span> :¬†None</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="feature.Feature" href="#feature.Feature">Feature</a></b></code>:
<ul class="hlist">
<li><code><a title="feature.Feature.business_logics" href="#feature.Feature.business_logics">business_logics</a></code></li>
<li><code><a title="feature.Feature.data_checks" href="#feature.Feature.data_checks">data_checks</a></code></li>
<li><code><a title="feature.Feature.freshness" href="#feature.Feature.freshness">freshness</a></code></li>
<li><code><a title="feature.Feature.human_datatype" href="#feature.Feature.human_datatype">human_datatype</a></code></li>
<li><code><a title="feature.Feature.input_features" href="#feature.Feature.input_features">input_features</a></code></li>
<li><code><a title="feature.Feature.input_lookups" href="#feature.Feature.input_lookups">input_lookups</a></code></li>
<li><code><a title="feature.Feature.metadata" href="#feature.Feature.metadata">metadata</a></code></li>
<li><code><a title="feature.Feature.ml_transformations" href="#feature.Feature.ml_transformations">ml_transformations</a></code></li>
<li><code><a title="feature.Feature.model_datatypes" href="#feature.Feature.model_datatypes">model_datatypes</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="feature.RawFeature"><code class="flex name class">
<span>class <span class="ident">RawFeature</span></span>
</code></dt>
<dd>
<div class="desc"><p>Data that comes directly from a DataProvider and will never be manipulated directly by Orchestra.
If a value here is ‚Äúbad‚Äù - it is 100% the fault of the DataProvider's owner üòâ</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RawFeature(Feature):
    &#34;&#34;&#34;
    Data that comes directly from a DataProvider and will never be manipulated directly by Orchestra.  If a value here is ‚Äúbad‚Äù - it is 100% the fault of the DataProvider&#39;s owner üòâ
    &#34;&#34;&#34;

    ml_transformations: None
    business_logic: None
    input_features: None

    freshness: timedelta
    &#34;&#34;&#34;
    Output only.
    Automatically generated by Orchestra based on the DatasetProvider attached to the Dataset
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="feature.Feature" href="#feature.Feature">Feature</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="feature.RawFeature.business_logic"><code class="name">var <span class="ident">business_logic</span> :¬†None</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="feature.Feature" href="#feature.Feature">Feature</a></b></code>:
<ul class="hlist">
<li><code><a title="feature.Feature.business_logics" href="#feature.Feature.business_logics">business_logics</a></code></li>
<li><code><a title="feature.Feature.data_checks" href="#feature.Feature.data_checks">data_checks</a></code></li>
<li><code><a title="feature.Feature.freshness" href="#feature.Feature.freshness">freshness</a></code></li>
<li><code><a title="feature.Feature.human_datatype" href="#feature.Feature.human_datatype">human_datatype</a></code></li>
<li><code><a title="feature.Feature.input_features" href="#feature.Feature.input_features">input_features</a></code></li>
<li><code><a title="feature.Feature.input_lookups" href="#feature.Feature.input_lookups">input_lookups</a></code></li>
<li><code><a title="feature.Feature.metadata" href="#feature.Feature.metadata">metadata</a></code></li>
<li><code><a title="feature.Feature.ml_transformations" href="#feature.Feature.ml_transformations">ml_transformations</a></code></li>
<li><code><a title="feature.Feature.model_datatypes" href="#feature.Feature.model_datatypes">model_datatypes</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="feature.Timestamp"><code class="flex name class">
<span>class <span class="ident">Timestamp</span></span>
</code></dt>
<dd>
<div class="desc"><p>A data value that represents the timestamp of when other Features in that row of data were created or updated.
Used for time-travel and time-aware joins.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Timestamp(Feature):
    &#34;&#34;&#34;
    A data value that represents the timestamp of when other Features in that row of data were created or updated.  Used for time-travel and time-aware joins.
    &#34;&#34;&#34;

    timestamp_format: str
    &#34;&#34;&#34;
    Format of the timestamp e.g., seconds since epoch, YYYYmmddHHss, etc
    &#34;&#34;&#34;

    # TODO: Should timestamp be a special sub-class or not? I think yes but 85% sure.

    ml_transformations: None
    business_logic: None
    input_features: None
    freshness: None
    data_checks: None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="feature.Feature" href="#feature.Feature">Feature</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="feature.Timestamp.business_logic"><code class="name">var <span class="ident">business_logic</span> :¬†None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="feature.Timestamp.timestamp_format"><code class="name">var <span class="ident">timestamp_format</span> :¬†str</code></dt>
<dd>
<div class="desc"><p>Format of the timestamp e.g., seconds since epoch, YYYYmmddHHss, etc</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="feature.Feature" href="#feature.Feature">Feature</a></b></code>:
<ul class="hlist">
<li><code><a title="feature.Feature.business_logics" href="#feature.Feature.business_logics">business_logics</a></code></li>
<li><code><a title="feature.Feature.data_checks" href="#feature.Feature.data_checks">data_checks</a></code></li>
<li><code><a title="feature.Feature.freshness" href="#feature.Feature.freshness">freshness</a></code></li>
<li><code><a title="feature.Feature.human_datatype" href="#feature.Feature.human_datatype">human_datatype</a></code></li>
<li><code><a title="feature.Feature.input_features" href="#feature.Feature.input_features">input_features</a></code></li>
<li><code><a title="feature.Feature.input_lookups" href="#feature.Feature.input_lookups">input_lookups</a></code></li>
<li><code><a title="feature.Feature.metadata" href="#feature.Feature.metadata">metadata</a></code></li>
<li><code><a title="feature.Feature.ml_transformations" href="#feature.Feature.ml_transformations">ml_transformations</a></code></li>
<li><code><a title="feature.Feature.model_datatypes" href="#feature.Feature.model_datatypes">model_datatypes</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="feature.Aggregation" href="#feature.Aggregation">Aggregation</a></code></h4>
<ul class="two-column">
<li><code><a title="feature.Aggregation.aggregate_by" href="#feature.Aggregation.aggregate_by">aggregate_by</a></code></li>
<li><code><a title="feature.Aggregation.aggregate_function" href="#feature.Aggregation.aggregate_function">aggregate_function</a></code></li>
<li><code><a title="feature.Aggregation.custom_function" href="#feature.Aggregation.custom_function">custom_function</a></code></li>
<li><code><a title="feature.Aggregation.order_by" href="#feature.Aggregation.order_by">order_by</a></code></li>
<li><code><a title="feature.Aggregation.records_needed" href="#feature.Aggregation.records_needed">records_needed</a></code></li>
<li><code><a title="feature.Aggregation.window" href="#feature.Aggregation.window">window</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="feature.DerivedFeature" href="#feature.DerivedFeature">DerivedFeature</a></code></h4>
</li>
<li>
<h4><code><a title="feature.Feature" href="#feature.Feature">Feature</a></code></h4>
<ul class="two-column">
<li><code><a title="feature.Feature.business_logics" href="#feature.Feature.business_logics">business_logics</a></code></li>
<li><code><a title="feature.Feature.data_checks" href="#feature.Feature.data_checks">data_checks</a></code></li>
<li><code><a title="feature.Feature.freshness" href="#feature.Feature.freshness">freshness</a></code></li>
<li><code><a title="feature.Feature.human_datatype" href="#feature.Feature.human_datatype">human_datatype</a></code></li>
<li><code><a title="feature.Feature.input_features" href="#feature.Feature.input_features">input_features</a></code></li>
<li><code><a title="feature.Feature.input_lookups" href="#feature.Feature.input_lookups">input_lookups</a></code></li>
<li><code><a title="feature.Feature.metadata" href="#feature.Feature.metadata">metadata</a></code></li>
<li><code><a title="feature.Feature.ml_transformations" href="#feature.Feature.ml_transformations">ml_transformations</a></code></li>
<li><code><a title="feature.Feature.model_datatypes" href="#feature.Feature.model_datatypes">model_datatypes</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="feature.Key" href="#feature.Key">Key</a></code></h4>
<ul class="">
<li><code><a title="feature.Key.business_logic" href="#feature.Key.business_logic">business_logic</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="feature.RawFeature" href="#feature.RawFeature">RawFeature</a></code></h4>
<ul class="">
<li><code><a title="feature.RawFeature.business_logic" href="#feature.RawFeature.business_logic">business_logic</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="feature.Timestamp" href="#feature.Timestamp">Timestamp</a></code></h4>
<ul class="">
<li><code><a title="feature.Timestamp.business_logic" href="#feature.Timestamp.business_logic">business_logic</a></code></li>
<li><code><a title="feature.Timestamp.timestamp_format" href="#feature.Timestamp.timestamp_format">timestamp_format</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>