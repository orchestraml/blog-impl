<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>code API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>code</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from typing import Literal, Dict, Optional
from common import Metadata


class Code:
    &#34;&#34;&#34;
    Parent class of all code types.
    Throws an error if used directly.
    &#34;&#34;&#34;

    metadata: Metadata
    &#34;&#34;&#34;
    name, description, key:value tags
    &#34;&#34;&#34;

    location: str
    &#34;&#34;&#34;
    TODO placeholder to link to Git&#34;&#34;&#34;


class ModelTrainingCode(Code):
    &#34;&#34;&#34;
    placeholder&#34;&#34;&#34;


class DataCode(Code):
    &#34;&#34;&#34;
    Code that takes 1+ Features and returns 1+ Features

    While some business logic such as `Aggregations` can be declared with Orchestra&#39;s library (and thus, the computations automagically orchestrated to run on your data infrastructure), Orchestra gives data scientists the flexibility to define their own custom business logic.  If your business logic fits within the `Aggregations` abstraction, we highly recommend doing so.

    For all other cases, the `DataCode` abstraction contains the business logic used by a `Feature` to transform the `input_features` to the final value.  Accordingly, every `DataCode` object MUST be linked to a `Feature`.

    We strongly suggest you follow the paradigm that data code only operates on the current row of data.  For a subset of DataCode types and freshness latencies, this enables the same code to work across both training and production environments.  However, should you need access to multiple rows of data, Orchestra provides three methods:

    1. If your logic is an aggregation, you can leverage a custom aggregation function [TODO link to custom aggregates]
    2. If your logic requires a join or lookup to another table, you can leverage the `input_datasources` that provides an abstraction to enable Orchestra to deliver the joined or looked-up data to your `DataCode`.
    3. If your logic requires a full table scan, TODO: are there any uses cases for a full table scan outside of ML transformations?

    Adding new types of `DataCode`.  The design of Orchestra is such that we operate blind to the imperative code itself (where orchestration requires awareness, there is a declarative interface) - this makes it straightforward for anyone to add a new data language/provider.

    &#34;&#34;&#34;

    input_records_needed = Literal[&#34;SingleRecord&#34;, &#34;Aggregation&#34;, &#34;AllRecords&#34;, &#34;Join&#34;]
    &#34;&#34;&#34;
    (default) SingleRecord: Only requires the data from a single record to execute (e.g., the current record being processed)

    Aggregation: Requires multiple records of data from the same GROUP BY features.

    Join: Requires records obtained by joining to a Dataset with differnet Key(s)

    AllRecords: Requires every record (or a statistical sample if using big data estimation algorithms)

    &#34;&#34;&#34;


class PythonDataCode(DataCode):
    &#34;&#34;&#34;
    Function definition must be one of these

    def python_data_code(records: List[dict], data_lookups: Dict[str, dict]) -&gt; dict:

        if `input_records_needed` = `Join`, `data_lookups` contains the joined records, otherwise, None
        return value must deliver all `output_features` inside the dict

        if `input_records_needed` = `SingleRecord`, `records` is just 1 record
        Otherwise, all records requested are included.

    def python_data_code(records: pd.Dataframe, data_lookups: Dict[str, pd.Dataframe]) -&gt; pd.Dataframe:

        same as above, just with Dataframes pre-loaded
        return value must deliver all output_features inside the DF

    &#34;&#34;&#34;

    python_modules: Optional[Dict[str, str]]
    &#34;&#34;&#34;
    Modules in the form of {&#39;module-nmae&#39;, &#39;1.0.33&#39;}
    &#34;&#34;&#34;

    requirements_txt: str
    &#34;&#34;&#34;
    requirements.txt file.  Combined with `python_modules` and `conda_yaml`
    &#34;&#34;&#34;

    conda_yaml: str
    &#34;&#34;&#34;
    conda.yaml file.  Combined with `python_modules` and `requirements_txt`
    &#34;&#34;&#34;

    python_version: str
    &#34;&#34;&#34;
    Python version in the format of &#39;3.7.22&#39;
    &#34;&#34;&#34;

    docker_container: Optional[str]
    &#34;&#34;&#34;
    Optional path to a docker container; otherwise the defaults are used
     &#34;&#34;&#34;


class PySparkDataCode(DataCode):
    &#34;&#34;&#34;

    def snowpark_data_code(records: pyspark.sql.DataFrame, data_lookups: Dict[str, pyspark.sql.DataFrame]) -&gt; pyspark.sql.DataFrame:

    &#34;&#34;&#34;


class SparkSQLDataCode(DataCode):
    &#34;&#34;&#34; &#34;&#34;&#34;


class SQLDataCode(DataCode):
    &#34;&#34;&#34;
    TODO: define this.
    this should be a string return value that can fit in at {XX}

    SELECT
    {XX},
    FROM table [...]

    case when {{input_feature_1}} is 1 then &#39;no&#39; else &#39;other&#39; end

    &#34;&#34;&#34;


class SnowparkDataCode(DataCode):
    &#34;&#34;&#34;

    Snowpark function

    def snowpark_data_code(records: snowflake.snowpark.DataFrame, data_lookups: Dict[str, snowflake.snowpark.DataFrame]) -&gt; snowflake.snowpark.DataFrame:
    &#34;&#34;&#34;


# TODO: Where do custom aggregation functions fit in?  I think they should be part of the Aggregations framework, but they will require DataCode...think this through.

# TODO: Define a multiple-feature abstraction e.g., let the data scientist deliver multiple features within one code block.

# TODO: Can we enable Connor&#39;s preferred journey (that I think is common) - the DS just wants to write some quick SQL and get some features to test.  How can we bring that into this framework with minimal overhead.  Loose thinking - [1] provide a translator from SQL to Orchestra object [2] use a multiple-feature object and use {{}} vars inside the sql code so we can have some level of understanding of what happens [3] ...

# TODO: Flesh out the table of languages we support.  What are the limtiations of each?  How can we design this to easily allow any data code for any data infra to work without us needing knowledge of that tool&#39;s language (e.g., we enable [insert new data tool] very easily)

# TODO: How do we run data code that does NOT run within the data infra?  e.g., SQL is easy to push to the database, but how do we run the Python code?  Probably looks something like a Docker image + push it to K8s within our controlled customer project?  Or maybe within an Airflow job in the customer&#39;s project (but we may run into scaling issues)

# TODO: Flesh out how you can define different data code for different environments e.g., production is in Java and development is in Python.  FWIW, I do not like this design pattern, but I think there will probably be some edge cases where it needs to happen.  Think more about this...

# TODO: Add more examples for add&#39;t data types
# [1] python code that takes dataframes as inputs
# [2] PySpark and SparkSQL
# [3] others?</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="code.Code"><code class="flex name class">
<span>class <span class="ident">Code</span></span>
</code></dt>
<dd>
<div class="desc"><p>Parent class of all code types.
Throws an error if used directly.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Code:
    &#34;&#34;&#34;
    Parent class of all code types.
    Throws an error if used directly.
    &#34;&#34;&#34;

    metadata: Metadata
    &#34;&#34;&#34;
    name, description, key:value tags
    &#34;&#34;&#34;

    location: str
    &#34;&#34;&#34;
    TODO placeholder to link to Git&#34;&#34;&#34;</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="code.DataCode" href="#code.DataCode">DataCode</a></li>
<li><a title="code.ModelTrainingCode" href="#code.ModelTrainingCode">ModelTrainingCode</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="code.Code.location"><code class="name">var <span class="ident">location</span> : str</code></dt>
<dd>
<div class="desc"><p>TODO placeholder to link to Git</p></div>
</dd>
<dt id="code.Code.metadata"><code class="name">var <span class="ident">metadata</span> : <a title="common.Metadata" href="common.html#common.Metadata">Metadata</a></code></dt>
<dd>
<div class="desc"><p>name, description, key:value tags</p></div>
</dd>
</dl>
</dd>
<dt id="code.DataCode"><code class="flex name class">
<span>class <span class="ident">DataCode</span></span>
</code></dt>
<dd>
<div class="desc"><p>Code that takes 1+ Features and returns 1+ Features</p>
<p>While some business logic such as <code>Aggregations</code> can be declared with Orchestra's library (and thus, the computations automagically orchestrated to run on your data infrastructure), Orchestra gives data scientists the flexibility to define their own custom business logic.
If your business logic fits within the <code>Aggregations</code> abstraction, we highly recommend doing so.</p>
<p>For all other cases, the <code><a title="code.DataCode" href="#code.DataCode">DataCode</a></code> abstraction contains the business logic used by a <code>Feature</code> to transform the <code>input_features</code> to the final value.
Accordingly, every <code><a title="code.DataCode" href="#code.DataCode">DataCode</a></code> object MUST be linked to a <code>Feature</code>.</p>
<p>We strongly suggest you follow the paradigm that data code only operates on the current row of data.
For a subset of DataCode types and freshness latencies, this enables the same code to work across both training and production environments.
However, should you need access to multiple rows of data, Orchestra provides three methods:</p>
<ol>
<li>If your logic is an aggregation, you can leverage a custom aggregation function [TODO link to custom aggregates]</li>
<li>If your logic requires a join or lookup to another table, you can leverage the <code>input_datasources</code> that provides an abstraction to enable Orchestra to deliver the joined or looked-up data to your <code><a title="code.DataCode" href="#code.DataCode">DataCode</a></code>.</li>
<li>If your logic requires a full table scan, TODO: are there any uses cases for a full table scan outside of ML transformations?</li>
</ol>
<p>Adding new types of <code><a title="code.DataCode" href="#code.DataCode">DataCode</a></code>.
The design of Orchestra is such that we operate blind to the imperative code itself (where orchestration requires awareness, there is a declarative interface) - this makes it straightforward for anyone to add a new data language/provider.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataCode(Code):
    &#34;&#34;&#34;
    Code that takes 1+ Features and returns 1+ Features

    While some business logic such as `Aggregations` can be declared with Orchestra&#39;s library (and thus, the computations automagically orchestrated to run on your data infrastructure), Orchestra gives data scientists the flexibility to define their own custom business logic.  If your business logic fits within the `Aggregations` abstraction, we highly recommend doing so.

    For all other cases, the `DataCode` abstraction contains the business logic used by a `Feature` to transform the `input_features` to the final value.  Accordingly, every `DataCode` object MUST be linked to a `Feature`.

    We strongly suggest you follow the paradigm that data code only operates on the current row of data.  For a subset of DataCode types and freshness latencies, this enables the same code to work across both training and production environments.  However, should you need access to multiple rows of data, Orchestra provides three methods:

    1. If your logic is an aggregation, you can leverage a custom aggregation function [TODO link to custom aggregates]
    2. If your logic requires a join or lookup to another table, you can leverage the `input_datasources` that provides an abstraction to enable Orchestra to deliver the joined or looked-up data to your `DataCode`.
    3. If your logic requires a full table scan, TODO: are there any uses cases for a full table scan outside of ML transformations?

    Adding new types of `DataCode`.  The design of Orchestra is such that we operate blind to the imperative code itself (where orchestration requires awareness, there is a declarative interface) - this makes it straightforward for anyone to add a new data language/provider.

    &#34;&#34;&#34;

    input_records_needed = Literal[&#34;SingleRecord&#34;, &#34;Aggregation&#34;, &#34;AllRecords&#34;, &#34;Join&#34;]
    &#34;&#34;&#34;
    (default) SingleRecord: Only requires the data from a single record to execute (e.g., the current record being processed)

    Aggregation: Requires multiple records of data from the same GROUP BY features.

    Join: Requires records obtained by joining to a Dataset with differnet Key(s)

    AllRecords: Requires every record (or a statistical sample if using big data estimation algorithms)

    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="code.Code" href="#code.Code">Code</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="code.PySparkDataCode" href="#code.PySparkDataCode">PySparkDataCode</a></li>
<li><a title="code.PythonDataCode" href="#code.PythonDataCode">PythonDataCode</a></li>
<li><a title="code.SQLDataCode" href="#code.SQLDataCode">SQLDataCode</a></li>
<li><a title="code.SnowparkDataCode" href="#code.SnowparkDataCode">SnowparkDataCode</a></li>
<li><a title="code.SparkSQLDataCode" href="#code.SparkSQLDataCode">SparkSQLDataCode</a></li>
<li><a title="feature.Aggregation" href="feature.html#feature.Aggregation">Aggregation</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="code.DataCode.input_records_needed"><code class="name">var <span class="ident">input_records_needed</span></code></dt>
<dd>
<div class="desc"><p>(default) SingleRecord: Only requires the data from a single record to execute (e.g., the current record being processed)</p>
<p>Aggregation: Requires multiple records of data from the same GROUP BY features.</p>
<p>Join: Requires records obtained by joining to a Dataset with differnet Key(s)</p>
<p>AllRecords: Requires every record (or a statistical sample if using big data estimation algorithms)</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="code.Code" href="#code.Code">Code</a></b></code>:
<ul class="hlist">
<li><code><a title="code.Code.location" href="#code.Code.location">location</a></code></li>
<li><code><a title="code.Code.metadata" href="#code.Code.metadata">metadata</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="code.ModelTrainingCode"><code class="flex name class">
<span>class <span class="ident">ModelTrainingCode</span></span>
</code></dt>
<dd>
<div class="desc"><p>placeholder</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ModelTrainingCode(Code):
    &#34;&#34;&#34;
    placeholder&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="code.Code" href="#code.Code">Code</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="code.Code" href="#code.Code">Code</a></b></code>:
<ul class="hlist">
<li><code><a title="code.Code.location" href="#code.Code.location">location</a></code></li>
<li><code><a title="code.Code.metadata" href="#code.Code.metadata">metadata</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="code.PySparkDataCode"><code class="flex name class">
<span>class <span class="ident">PySparkDataCode</span></span>
</code></dt>
<dd>
<div class="desc"><p>def snowpark_data_code(records: pyspark.sql.DataFrame, data_lookups: Dict[str, pyspark.sql.DataFrame]) -&gt; pyspark.sql.DataFrame:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PySparkDataCode(DataCode):
    &#34;&#34;&#34;

    def snowpark_data_code(records: pyspark.sql.DataFrame, data_lookups: Dict[str, pyspark.sql.DataFrame]) -&gt; pyspark.sql.DataFrame:

    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="code.DataCode" href="#code.DataCode">DataCode</a></li>
<li><a title="code.Code" href="#code.Code">Code</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="code.DataCode" href="#code.DataCode">DataCode</a></b></code>:
<ul class="hlist">
<li><code><a title="code.DataCode.input_records_needed" href="#code.DataCode.input_records_needed">input_records_needed</a></code></li>
</ul>
</li>
<li><code><b><a title="code.Code" href="#code.Code">Code</a></b></code>:
<ul class="hlist">
<li><code><a title="code.Code.location" href="#code.Code.location">location</a></code></li>
<li><code><a title="code.Code.metadata" href="#code.Code.metadata">metadata</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="code.PythonDataCode"><code class="flex name class">
<span>class <span class="ident">PythonDataCode</span></span>
</code></dt>
<dd>
<div class="desc"><p>Function definition must be one of these</p>
<p>def python_data_code(records: List[dict], data_lookups: Dict[str, dict]) -&gt; dict:</p>
<pre><code>if &lt;code&gt;input\_records\_needed&lt;/code&gt; = &lt;code&gt;Join&lt;/code&gt;, &lt;code&gt;data\_lookups&lt;/code&gt; contains the joined records, otherwise, None
return value must deliver all &lt;code&gt;output\_features&lt;/code&gt; inside the dict

if &lt;code&gt;input\_records\_needed&lt;/code&gt; = &lt;code&gt;SingleRecord&lt;/code&gt;, &lt;code&gt;records&lt;/code&gt; is just 1 record
Otherwise, all records requested are included.
</code></pre>
<p>def python_data_code(records: pd.Dataframe, data_lookups: Dict[str, pd.Dataframe]) -&gt; pd.Dataframe:</p>
<pre><code>same as above, just with Dataframes pre-loaded
return value must deliver all output_features inside the DF
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PythonDataCode(DataCode):
    &#34;&#34;&#34;
    Function definition must be one of these

    def python_data_code(records: List[dict], data_lookups: Dict[str, dict]) -&gt; dict:

        if `input_records_needed` = `Join`, `data_lookups` contains the joined records, otherwise, None
        return value must deliver all `output_features` inside the dict

        if `input_records_needed` = `SingleRecord`, `records` is just 1 record
        Otherwise, all records requested are included.

    def python_data_code(records: pd.Dataframe, data_lookups: Dict[str, pd.Dataframe]) -&gt; pd.Dataframe:

        same as above, just with Dataframes pre-loaded
        return value must deliver all output_features inside the DF

    &#34;&#34;&#34;

    python_modules: Optional[Dict[str, str]]
    &#34;&#34;&#34;
    Modules in the form of {&#39;module-nmae&#39;, &#39;1.0.33&#39;}
    &#34;&#34;&#34;

    requirements_txt: str
    &#34;&#34;&#34;
    requirements.txt file.  Combined with `python_modules` and `conda_yaml`
    &#34;&#34;&#34;

    conda_yaml: str
    &#34;&#34;&#34;
    conda.yaml file.  Combined with `python_modules` and `requirements_txt`
    &#34;&#34;&#34;

    python_version: str
    &#34;&#34;&#34;
    Python version in the format of &#39;3.7.22&#39;
    &#34;&#34;&#34;

    docker_container: Optional[str]
    &#34;&#34;&#34;
    Optional path to a docker container; otherwise the defaults are used
     &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="code.DataCode" href="#code.DataCode">DataCode</a></li>
<li><a title="code.Code" href="#code.Code">Code</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="code.PythonDataCode.conda_yaml"><code class="name">var <span class="ident">conda_yaml</span> : str</code></dt>
<dd>
<div class="desc"><p>conda.yaml file.
Combined with <code>python_modules</code> and <code>requirements_txt</code></p></div>
</dd>
<dt id="code.PythonDataCode.docker_container"><code class="name">var <span class="ident">docker_container</span> : Optional[str]</code></dt>
<dd>
<div class="desc"><p>Optional path to a docker container; otherwise the defaults are used</p></div>
</dd>
<dt id="code.PythonDataCode.python_modules"><code class="name">var <span class="ident">python_modules</span> : Optional[Dict[str, str]]</code></dt>
<dd>
<div class="desc"><p>Modules in the form of {'module-nmae', '1.0.33'}</p></div>
</dd>
<dt id="code.PythonDataCode.python_version"><code class="name">var <span class="ident">python_version</span> : str</code></dt>
<dd>
<div class="desc"><p>Python version in the format of '3.7.22'</p></div>
</dd>
<dt id="code.PythonDataCode.requirements_txt"><code class="name">var <span class="ident">requirements_txt</span> : str</code></dt>
<dd>
<div class="desc"><p>requirements.txt file.
Combined with <code>python_modules</code> and <code>conda_yaml</code></p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="code.DataCode" href="#code.DataCode">DataCode</a></b></code>:
<ul class="hlist">
<li><code><a title="code.DataCode.input_records_needed" href="#code.DataCode.input_records_needed">input_records_needed</a></code></li>
</ul>
</li>
<li><code><b><a title="code.Code" href="#code.Code">Code</a></b></code>:
<ul class="hlist">
<li><code><a title="code.Code.location" href="#code.Code.location">location</a></code></li>
<li><code><a title="code.Code.metadata" href="#code.Code.metadata">metadata</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="code.SQLDataCode"><code class="flex name class">
<span>class <span class="ident">SQLDataCode</span></span>
</code></dt>
<dd>
<div class="desc"><p>TODO: define this.
this should be a string return value that can fit in at {XX}</p>
<p>SELECT
{XX},
FROM table [&hellip;]</p>
<p>case when {{input_feature_1}} is 1 then 'no' else 'other' end</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SQLDataCode(DataCode):
    &#34;&#34;&#34;
    TODO: define this.
    this should be a string return value that can fit in at {XX}

    SELECT
    {XX},
    FROM table [...]

    case when {{input_feature_1}} is 1 then &#39;no&#39; else &#39;other&#39; end

    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="code.DataCode" href="#code.DataCode">DataCode</a></li>
<li><a title="code.Code" href="#code.Code">Code</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="code.DataCode" href="#code.DataCode">DataCode</a></b></code>:
<ul class="hlist">
<li><code><a title="code.DataCode.input_records_needed" href="#code.DataCode.input_records_needed">input_records_needed</a></code></li>
</ul>
</li>
<li><code><b><a title="code.Code" href="#code.Code">Code</a></b></code>:
<ul class="hlist">
<li><code><a title="code.Code.location" href="#code.Code.location">location</a></code></li>
<li><code><a title="code.Code.metadata" href="#code.Code.metadata">metadata</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="code.SnowparkDataCode"><code class="flex name class">
<span>class <span class="ident">SnowparkDataCode</span></span>
</code></dt>
<dd>
<div class="desc"><p>Snowpark function</p>
<p>def snowpark_data_code(records: snowflake.snowpark.DataFrame, data_lookups: Dict[str, snowflake.snowpark.DataFrame]) -&gt; snowflake.snowpark.DataFrame:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SnowparkDataCode(DataCode):
    &#34;&#34;&#34;

    Snowpark function

    def snowpark_data_code(records: snowflake.snowpark.DataFrame, data_lookups: Dict[str, snowflake.snowpark.DataFrame]) -&gt; snowflake.snowpark.DataFrame:
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="code.DataCode" href="#code.DataCode">DataCode</a></li>
<li><a title="code.Code" href="#code.Code">Code</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="code.DataCode" href="#code.DataCode">DataCode</a></b></code>:
<ul class="hlist">
<li><code><a title="code.DataCode.input_records_needed" href="#code.DataCode.input_records_needed">input_records_needed</a></code></li>
</ul>
</li>
<li><code><b><a title="code.Code" href="#code.Code">Code</a></b></code>:
<ul class="hlist">
<li><code><a title="code.Code.location" href="#code.Code.location">location</a></code></li>
<li><code><a title="code.Code.metadata" href="#code.Code.metadata">metadata</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="code.SparkSQLDataCode"><code class="flex name class">
<span>class <span class="ident">SparkSQLDataCode</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SparkSQLDataCode(DataCode):
    &#34;&#34;&#34; &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="code.DataCode" href="#code.DataCode">DataCode</a></li>
<li><a title="code.Code" href="#code.Code">Code</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="code.DataCode" href="#code.DataCode">DataCode</a></b></code>:
<ul class="hlist">
<li><code><a title="code.DataCode.input_records_needed" href="#code.DataCode.input_records_needed">input_records_needed</a></code></li>
</ul>
</li>
<li><code><b><a title="code.Code" href="#code.Code">Code</a></b></code>:
<ul class="hlist">
<li><code><a title="code.Code.location" href="#code.Code.location">location</a></code></li>
<li><code><a title="code.Code.metadata" href="#code.Code.metadata">metadata</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="code.Code" href="#code.Code">Code</a></code></h4>
<ul class="">
<li><code><a title="code.Code.location" href="#code.Code.location">location</a></code></li>
<li><code><a title="code.Code.metadata" href="#code.Code.metadata">metadata</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="code.DataCode" href="#code.DataCode">DataCode</a></code></h4>
<ul class="">
<li><code><a title="code.DataCode.input_records_needed" href="#code.DataCode.input_records_needed">input_records_needed</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="code.ModelTrainingCode" href="#code.ModelTrainingCode">ModelTrainingCode</a></code></h4>
</li>
<li>
<h4><code><a title="code.PySparkDataCode" href="#code.PySparkDataCode">PySparkDataCode</a></code></h4>
</li>
<li>
<h4><code><a title="code.PythonDataCode" href="#code.PythonDataCode">PythonDataCode</a></code></h4>
<ul class="">
<li><code><a title="code.PythonDataCode.conda_yaml" href="#code.PythonDataCode.conda_yaml">conda_yaml</a></code></li>
<li><code><a title="code.PythonDataCode.docker_container" href="#code.PythonDataCode.docker_container">docker_container</a></code></li>
<li><code><a title="code.PythonDataCode.python_modules" href="#code.PythonDataCode.python_modules">python_modules</a></code></li>
<li><code><a title="code.PythonDataCode.python_version" href="#code.PythonDataCode.python_version">python_version</a></code></li>
<li><code><a title="code.PythonDataCode.requirements_txt" href="#code.PythonDataCode.requirements_txt">requirements_txt</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="code.SQLDataCode" href="#code.SQLDataCode">SQLDataCode</a></code></h4>
</li>
<li>
<h4><code><a title="code.SnowparkDataCode" href="#code.SnowparkDataCode">SnowparkDataCode</a></code></h4>
</li>
<li>
<h4><code><a title="code.SparkSQLDataCode" href="#code.SparkSQLDataCode">SparkSQLDataCode</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>